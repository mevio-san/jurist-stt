import time
import json
import logging
import random

class CloudWatchJsonFormatter(logging.Formatter):
  """
  Formatter that outputs JSON strings after parsing the LogRecord.

  @param dict fmt_list: logging format attribute list. Defaults to ["message"].
  """
  def __init__(self, fmt_list: list = None, corr_id: bool = False):
    self._fmt_list = fmt_list if fmt_list is not None else ["message"]
    if corr_id:
      self._fmt_list.append("corr_id")
    self._corr_id = self._get_corr_id() if corr_id else None

  @staticmethod
  def _get_corr_id():
    """
    Generates a random correlation ID in hexadecimal format.
    
    Returns:
    - A string representing a randomly generated 8-character hexadecimal ID.
    """
    return f'{random.randint(0, 2 ** 32 - 1):0>4X}'

  def formatMessage(self, record) -> dict:
    """
    Overwritten to return a dictionary of the relevant LogRecord attributes instead of a string. 
    """
    msg_dict = {fmt_key: record.__dict__[fmt_key] for fmt_key in self._fmt_list if record.__dict__.get(fmt_key)}
    if self._corr_id:
      msg_dict["corr_id"] = self._corr_id
    return msg_dict

  def format(self, record) -> str:
    """
    Mostly the same as the parent's class method, the difference being that a dict is manipulated and dumped as JSON
    instead of a string.
    """
    record.message = record.getMessage()

    message_dict = self.formatMessage(record)

    if record.exc_info:
      # Cache the traceback text to avoid converting it multiple times
      # (it's constant anyway)
      if not record.exc_text:
        record.exc_text = self.formatException(record.exc_info)

    if record.exc_text:
      message_dict["exc_info"] = record.exc_text

    if record.stack_info:
      message_dict["stack_info"] = self.formatStack(record.stack_info)

    return json.dumps(message_dict, default=str)
        
class CloudWatchLoggerHandler(logging.Handler):
  """
  A custom logging handler that sends logs to AWS CloudWatch using a worker thread.
  """
  def __init__(self, worker):
    """
    Initializes the CloudWatchHandler.

    Parameters:
    - worker: An instance of CloudWatchLoggerWorker that handles log buffering and submission.
    """
    super().__init__()
    self.__worker = worker
    self.__worker.start() # Start the worker thread to process logs asynchronously
  
  def createLock(self):
    """
    Overriding `createLock` to do nothing. We elide a useless lock for performance.
    This method is usually used for thread safety, but the worker's queue is already thread safe.
    """
    pass
  
  def acquire(self):
    """
    Overriding `acquire` to do nothing.
    This method is usually used for thread safety, but the worker's queue is already thread safe.
    """
    pass
  
  def release(self):
    """
    Overriding `release` to do nothing.
    This method is usually used for thread safety, but the worker's queue is already thread safe.
    """
    pass

  def emit(self, record):
    """
    Processes and sends a log record to the CloudWatch worker.

    Parameters:
    - record: A log record generated by the Python logging system.
    """
    self.__worker.append({
      'timestamp': round(time.time() * 1000), # Convert time to milliseconds
      'message': self.format(record) # Format the log message before sending
    })

  def flush(self):
    """
    Manually triggers a flush of the log buffer to CloudWatch.
    """
    self.__worker._flush()
  
  def close(self):
    """
    Closes the handler and performs cleanup.
    Calls the superclass close method.
    """
    super().close()
